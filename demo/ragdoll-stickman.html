<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Prosthetic Calibration - Ragdoll Stickman</title>
  <style>
    body { margin: 0; background: #232332; color: #f2f2f2; font-family: system-ui, sans-serif;}
    .ui { position: absolute; left: 0; top: 0; width: 320px; background: #232342; min-height: 100vh; padding: 18px 12px 12px 18px;}
    .ui h2 { margin: 2px 0 10px 0; font-size: 18px; color: #fff; }
    .ui .group { margin-bottom: 22px; }
    .ui label { display:block; margin-top:8px;}
    .ui .num { width:54px;}
    #main { margin-left: 330px;}
    #progress { margin: 8px 0;}
    .cdx { color: #31a4fa; }
    .cdy { color: #85f27b; }
    .cgrey { color: #bbb;}
    #learningbar { width:90%; height: 7px; background:#333; border-radius:5px;}
    #learningbar > div { background: #31a4fa; height:100%; border-radius:5px;}
  </style>
</head>
<body>
<div class="ui">
<h2>Prosthetic Calibration - Ragdoll Stickman</h2>
<p style="color:#bbb; font-size: 12px;">Stickman centers on load; right leg highlighted; learns smoother gait over time</p>
<div class="group"><b>Physics tuning</b>
  <br>Torque <input type="range" min="0.5" max="3" step="0.01" value="1.0" id="torque"/>
  <input type="number" min="0.5" max="3" step="0.01" value="1.0" class="num" id="n_torque"/>
  <br>Restitution <input type="range" min="0.1" max="1.0" step="0.01" value="0.3" id="resti"/>
  <input type="number" min="0.1" max="1.0" step="0.01" value="0.3" class="num" id="n_resti"/>
  <br>Balance bias <input type="range" min="-1" max="1" step="0.02" value="0" id="bbias"/>
  <input type="number" min="-1" max="1" step="0.02" value="0" class="num" id="n_bbias"/>
  <br>
  <input type="checkbox" id="showeng"/> Show energy panel
</div>
<div class="group"><b>Live metrics</b>
  <div>Knee (R / L) <span class="cdx" id="kneeR">0</span>° / <span class="cdy" id="kneeL">0</span>°</div>
  <div>Ankle (R / L) <span class="cdx" id="ankleR">0</span>° / <span class="cdy" id="ankleL">0</span>°</div>
  <div>Resistance <span class="cgrey" id="resist">0.30</span></div>
  <div>Comfort <span class="cgrey" id="comfort">100</span></div>
  <div>Energy <span class="cgrey" id="energy">0.00</span></div>
  <div>Steps <span class="cgrey" id="steps">0</span></div>
  <div>Cadence <span class="cgrey" id="cadence">0.00</span></div>
</div>
<div class="group"><b>Learning progress</b>
  <div id="progress"><div id="learningbar"><div style="width:0%"></div></div></div>
  <div id="lstat" style="color:#6ae3ff;">Initializing gait policy…</div>
</div>
</div>
<div id="main"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
<script>
const { Engine, Render, World, Bodies, Constraint, Mouse, MouseConstraint, Body, Composite } = Matter;
let W = 800, H = 600;
const mainDiv = document.getElementById("main");
mainDiv.style.position = "relative";
mainDiv.innerHTML = `<canvas width="${W}" height="${H}" style="display:block;background:#18192c; margin:30px auto 0 auto;border-radius:18px;"></canvas>`;
const canvas = mainDiv.querySelector("canvas");

// Setup Matter.js
const engine = Engine.create();
const render = Render.create({
  canvas: canvas,
  engine: engine,
  options: { width: W, height: H, wireframes: false, background: "#18192c" }
});

// Start centered
let cx = W/2, cy = H/2-70;

function makeStickman(centerX, centerY, optics={}) {
  // Head
  const head = Bodies.circle(centerX, centerY-50, 23, { restitution:0.4, density:0.01, render: { fillStyle: "#F5DEB3" } });
  // Torso + Pelvis
  const torso = Bodies.rectangle(centerX, centerY+22, 27, 76, { density:0.01, render:{ fillStyle: "#666" } });

  // Shoulders
  const uar = Bodies.rectangle(centerX-38, centerY-10, 48, 13, { density:0.008, render:{ fillStyle: "#777" } }); // right
  const ual = Bodies.rectangle(centerX+38, centerY-10, 48, 13, { density:0.008, render:{ fillStyle: "#777" } }); // left
  const lar = Bodies.rectangle(centerX-74, centerY-10, 38, 12, { density:0.008, render:{ fillStyle: "#bbb" } });
  const lal = Bodies.rectangle(centerX+74, centerY-10, 38, 12, { density:0.008, render:{ fillStyle: "#bbb" } });

  // Legs (right is blue, left is green)
  const ulr = Bodies.rectangle(centerX-11, centerY+74, 17, 60, { density:0.011, render:{ fillStyle: "#2e80ed" } });
  const ull = Bodies.rectangle(centerX+11, centerY+74, 17, 60, { density:0.011, render:{ fillStyle: "#85f27b" } });
  const llr = Bodies.rectangle(centerX-11, centerY+120, 13, 54, { density:0.012, render:{ fillStyle: "#2e80ed" } });
  const lll = Bodies.rectangle(centerX+11, centerY+120, 13, 54, { density:0.012, render:{ fillStyle: "#85f27b" } });

  // Constraints
  const cons = [
    Constraint.create({ bodyA: head, pointA:{x:0,y:23}, bodyB:torso, pointB:{x:0, y:-36}, stiffness: 0.7 }),
    Constraint.create({ bodyA: torso, pointA:{x:-13, y:-34}, bodyB:uar, pointB:{x:24, y:0}, length: 0, stiffness: 0.6 }),
    Constraint.create({ bodyA: torso, pointA:{x: 13, y:-34}, bodyB:ual, pointB:{x:-24, y:0}, length: 0, stiffness: 0.6 }),
    Constraint.create({ bodyA: uar, pointA:{x:-24, y:0}, bodyB:lar, pointB:{x:19,y:0}, length: 0, stiffness: 0.5 }),
    Constraint.create({ bodyA: ual, pointA:{x:24, y:0}, bodyB:lal, pointB:{x:-19,y:0}, length: 0, stiffness: 0.5 }),
    // Torso-Hips
    Constraint.create({ bodyA: torso, pointA:{x:-7, y:38}, bodyB:ulr, pointB:{x:0,y:-30}, stiffness:0.7 }),
    Constraint.create({ bodyA: torso, pointA:{x:7, y:38}, bodyB:ull, pointB:{x:0,y:-30}, stiffness:0.7 }),
    // Knees
    Constraint.create({ bodyA: ulr, pointA:{x:0,y:30}, bodyB:llr, pointB:{x:0,y:-25}, stiffness:0.66 }),
    Constraint.create({ bodyA: ull, pointA:{x:0,y:30}, bodyB:lll, pointB:{x:0,y:-25}, stiffness:0.66 }),
    // Feet to ground (light)
    Constraint.create({ bodyA: llr, pointA:{x:0,y:25}, pointB:{x:centerX-11, y:H-35}, stiffness:0.08, length:10, render:{visible:false} }),
    Constraint.create({ bodyA: lll, pointA:{x:0,y:25}, pointB:{x:centerX+11, y:H-35}, stiffness:0.08, length:10, render:{visible:false} }),
  ];

  // Add all to world as an array for later reference
  World.add(engine.world, [head, torso, uar, ual, lar, lal, ulr, ull, llr, lll]);
  World.add(engine.world, cons);

  return {head, torso, uar, ual, lar, lal, ulr, ull, llr, lll, cons};
}
 
// Remove previous stickmen on reloads, add one centered
Composite.clear(engine.world, false, true);
const ground = Bodies.rectangle(W/2, H-24, W, 26, { isStatic:true, render:{ fillStyle: "#18192c" }});
World.add(engine.world, ground);
// Make stickman
const stick = makeStickman(cx, cy);

// Drag support
World.add(engine.world, MouseConstraint.create(engine, {
  mouse: Mouse.create(render.canvas),
  constraint: { stiffness: 0.4, render: {visible: false } }
}));

Engine.run(engine); Render.run(render);

// ---- Live learning logic ----
let learnPct = 0, comfort = 100, unstable = 0, energy = 0, steps = 0, lastFootY = null, frameCount = 0;
let simulateWalking = false;
function animateLearningStep() {
  // Simple simulated learning: every 2s, increase learning %
  if (learnPct < 100) {
    learnPct += 0.23;
    document.getElementById('learningbar').firstElementChild.style.width = `${learnPct|0}%`;
    if (learnPct > 100) learnPct = 100;
    // Simulate improved gait! Reduce torque delta, improve restitution, etc.
    let torque = 1.0 + (1 - learnPct/100)*0.7;
    let resti = 0.3 + (1-learnPct/100)*0.4;
    let cval = 100 - (1-learnPct/100)*45;
    document.getElementById("torque").value = torque.toFixed(2);
    document.getElementById("resti").value = resti.toFixed(2);
    comfort = cval|0;
    document.getElementById("n_torque").value = torque.toFixed(2);
    document.getElementById("n_resti").value = resti.toFixed(2);
    document.getElementById("comfort").textContent = comfort;
    document.getElementById("lstat").textContent = `Learning... gait smoothness ${(comfort|0)}/100`;
    updateStickmanPhysics(+torque, +resti);
  } else {
    document.getElementById("lstat").textContent = "Gait optimized. Comfort at maximum.";
    simulateWalking = true;
  }
  setTimeout(animateLearningStep, 102);
}
animateLearningStep();

// Update stickman physics to simulate 'improving'
function updateStickmanPhysics(torque, resti) {
  [stick.ulr, stick.ull, stick.llr, stick.lll].forEach(seg => { seg.restitution = resti; });
  [stick.ulr, stick.llr, stick.uar, stick.lar].forEach(seg => { seg.friction = 0.08+torque*0.02; });
  [stick.ull, stick.lll, stick.ual, stick.lal].forEach(seg => { seg.friction = 0.08+torque*0.02; });
}
// ---- UI binding ----
let updateUI = () => {
  // Fake sensor metrics (angles based on positions)
  let rightKnee = getJointAngle(stick.ulr, stick.llr), leftKnee = getJointAngle(stick.ull, stick.lll);
  let rightAnkle = getAnkleAngle(stick.llr), leftAnkle = getAnkleAngle(stick.lll);

  document.getElementById("kneeR").textContent = rightKnee|0;
  document.getElementById("kneeL").textContent = leftKnee|0;
  document.getElementById("ankleR").textContent = rightAnkle|0;
  document.getElementById("ankleL").textContent = leftAnkle|0;
  document.getElementById("resist").textContent = (+document.getElementById("resti").value).toFixed(2);
  document.getElementById("comfort").textContent = comfort;
  document.getElementById("energy").textContent = energy.toFixed(2);
  document.getElementById("steps").textContent = steps;
  document.getElementById("cadence").textContent = (steps/((frameCount/60)||1)).toFixed(2);
};
setInterval(updateUI, 80);

// --- Walking/comfort: simulate step motion after learning ---
setInterval(()=>{
  frameCount++;
  if (simulateWalking && frameCount%30 === 0) {
    // Nudge hips to step, alternate legs
    let left = (frameCount%(60*2))<60;
    let bod = left ? stick.lll : stick.llr;
    let delta = left ? -2.5 : 2.5;
    Body.setVelocity(bod, {x:delta, y: -2});
    steps++;
    energy += Math.abs(delta)*0.5;
    if (lastFootY !== null) {
      comfort += Math.abs(bod.position.y - lastFootY)<3 ? 2 : -2;
      comfort = Math.max(0, Math.min(comfort, 100));
    }
    lastFootY = bod.position.y;
  }
},33);

// Utility: calculate angle between two segments
function getJointAngle(segA, segB) {
  let dx1 = segA.position.x - stick.torso.position.x, dy1 = segA.position.y - stick.torso.position.y;
  let dx2 = segB.position.x - segA.position.x, dy2 = segB.position.y - segA.position.y;
  return Math.abs((Math.atan2(dy2,dx2)-Math.atan2(dy1,dx1))*180/Math.PI)|0;
}
function getAnkleAngle(seg) {
  return Math.abs((Math.atan2(seg.position.y - H+35, seg.position.x - (seg.position.x<cx?cx-11:cx+11))*180/Math.PI))|0;
}
// Link UI control sliders
function sliderControl(id, handler) {
  let slider = document.getElementById(id), num = document.getElementById('n_'+id);
  [slider,num].forEach(inp=>{
    inp.oninput = function() { slider.value = num.value = this.value; handler(+this.value); };
  });
}
sliderControl('torque', v=>updateStickmanPhysics(v, +document.getElementById('resti').value));
sliderControl('resti', v=>updateStickmanPhysics(+document.getElement
